/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, Inject, forwardRef } from '@angular/core';
import { connectToggle } from 'instantsearch.js/es/connectors';
import { BaseWidget } from '../base-widget';
import { NgAisInstantSearch } from '../instantsearch/instantsearch';
import { noop } from '../utils';
export class NgAisToggle extends BaseWidget {
    /**
     * @param {?} instantSearchParent
     */
    constructor(instantSearchParent) {
        super('ToggleRefinement');
        this.instantSearchParent = instantSearchParent;
        this.values = { on: true, off: undefined };
        this.state = {
            createURL: noop,
            refine: noop,
            value: {},
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.createWidget(connectToggle, {
            attributeName: this.attribute,
            label: this.label,
            values: this.values,
        });
        super.ngOnInit();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleClick(event) {
        event.preventDefault();
        event.stopPropagation();
        this.state.refine(this.state.value);
    }
}
NgAisToggle.decorators = [
    { type: Component, args: [{
                selector: 'ais-toggle',
                template: `
    <div [class]="cx()">
      <ul [class]="cx('list')">
        <li
          [class]="cx('item')"
          (click)="handleClick($event)">
          <label [class]="cx('label')">
            <input
              [class]="cx('checkbox')"
              type="checkbox"
              value="{{state.value.name}}"
              [checked]="state.value.isRefined"
            />

            <span [class]="cx('labelText')">
              {{label || state.value.name}}
            </span>

            <span [class]="cx('count')">{{state.value.count}}</span>
          </label>
        </li>
      </ul>
    </div>
  `,
            },] },
];
/** @nocollapse */
NgAisToggle.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef(() => NgAisInstantSearch),] }] }
];
NgAisToggle.propDecorators = {
    attribute: [{ type: Input }],
    label: [{ type: Input }],
    values: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NgAisToggle.prototype.attribute;
    /** @type {?} */
    NgAisToggle.prototype.label;
    /** @type {?} */
    NgAisToggle.prototype.values;
    /** @type {?} */
    NgAisToggle.prototype.state;
    /** @type {?} */
    NgAisToggle.prototype.instantSearchParent;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1pbnN0YW50c2VhcmNoLyIsInNvdXJjZXMiOlsidG9nZ2xlL3RvZ2dsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVyRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDL0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxVQUFVLENBQUM7QUF1Q2hDLE1BQU0sT0FBTyxXQUFZLFNBQVEsVUFBVTs7OztJQWF6QyxZQUVTLG1CQUF3QjtRQUUvQixLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUZuQix3QkFBbUIsR0FBbkIsbUJBQW1CLENBQUs7UUFWMUIsV0FBTSxHQUFvQyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxDQUFDO1FBRXZFLFVBQUssR0FBZ0I7WUFDMUIsU0FBUyxFQUFFLElBQUk7WUFDZixNQUFNLEVBQUUsSUFBSTtZQUNaLEtBQUssRUFBRSxFQUFFO1NBQ1YsQ0FBQztJQU9GLENBQUM7Ozs7SUFFTSxRQUFRO1FBQ2IsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUU7WUFDL0IsYUFBYSxFQUFFLElBQUksQ0FBQyxTQUFTO1lBQzdCLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztZQUNqQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07U0FDcEIsQ0FBQyxDQUFDO1FBQ0gsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25CLENBQUM7Ozs7O0lBRU0sV0FBVyxDQUFDLEtBQWlCO1FBQ2xDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN2QixLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN0QyxDQUFDOzs7WUE1REYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxZQUFZO2dCQUN0QixRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUJUO2FBQ0Y7Ozs7NENBZUksTUFBTSxTQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQzs7O3dCQVo3QyxLQUFLO29CQUNMLEtBQUs7cUJBQ0wsS0FBSzs7OztJQUZOLGdDQUFrQzs7SUFDbEMsNEJBQThCOztJQUM5Qiw2QkFDOEU7O0lBRTlFLDRCQUlFOztJQUdBLDBDQUMrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIEluamVjdCwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBjb25uZWN0VG9nZ2xlIH0gZnJvbSAnaW5zdGFudHNlYXJjaC5qcy9lcy9jb25uZWN0b3JzJztcbmltcG9ydCB7IEJhc2VXaWRnZXQgfSBmcm9tICcuLi9iYXNlLXdpZGdldCc7XG5pbXBvcnQgeyBOZ0Fpc0luc3RhbnRTZWFyY2ggfSBmcm9tICcuLi9pbnN0YW50c2VhcmNoL2luc3RhbnRzZWFyY2gnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IHR5cGUgVG9nZ2xlU3RhdGUgPSB7XG4gIGNyZWF0ZVVSTDogRnVuY3Rpb247XG4gIHJlZmluZTogRnVuY3Rpb247XG4gIHZhbHVlOiB7XG4gICAgbmFtZT86IHN0cmluZztcbiAgICBjb3VudD86IG51bWJlcjtcbiAgICBpc1JlZmluZWQ/OiBib29sZWFuO1xuICB9O1xufTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYWlzLXRvZ2dsZScsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBbY2xhc3NdPVwiY3goKVwiPlxuICAgICAgPHVsIFtjbGFzc109XCJjeCgnbGlzdCcpXCI+XG4gICAgICAgIDxsaVxuICAgICAgICAgIFtjbGFzc109XCJjeCgnaXRlbScpXCJcbiAgICAgICAgICAoY2xpY2spPVwiaGFuZGxlQ2xpY2soJGV2ZW50KVwiPlxuICAgICAgICAgIDxsYWJlbCBbY2xhc3NdPVwiY3goJ2xhYmVsJylcIj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICBbY2xhc3NdPVwiY3goJ2NoZWNrYm94JylcIlxuICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICB2YWx1ZT1cInt7c3RhdGUudmFsdWUubmFtZX19XCJcbiAgICAgICAgICAgICAgW2NoZWNrZWRdPVwic3RhdGUudmFsdWUuaXNSZWZpbmVkXCJcbiAgICAgICAgICAgIC8+XG5cbiAgICAgICAgICAgIDxzcGFuIFtjbGFzc109XCJjeCgnbGFiZWxUZXh0JylcIj5cbiAgICAgICAgICAgICAge3tsYWJlbCB8fCBzdGF0ZS52YWx1ZS5uYW1lfX1cbiAgICAgICAgICAgIDwvc3Bhbj5cblxuICAgICAgICAgICAgPHNwYW4gW2NsYXNzXT1cImN4KCdjb3VudCcpXCI+e3tzdGF0ZS52YWx1ZS5jb3VudH19PC9zcGFuPlxuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvbGk+XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PlxuICBgLFxufSlcbmV4cG9ydCBjbGFzcyBOZ0Fpc1RvZ2dsZSBleHRlbmRzIEJhc2VXaWRnZXQge1xuICAvLyBjb25uZWN0b3Igb3B0aW9uc1xuICBASW5wdXQoKSBwdWJsaWMgYXR0cmlidXRlOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHB1YmxpYyBsYWJlbDogc3RyaW5nO1xuICBASW5wdXQoKVxuICBwdWJsaWMgdmFsdWVzOiB7IG9uPzogYm9vbGVhbjsgb2ZmPzogYm9vbGVhbiB9ID0geyBvbjogdHJ1ZSwgb2ZmOiB1bmRlZmluZWQgfTtcblxuICBwdWJsaWMgc3RhdGU6IFRvZ2dsZVN0YXRlID0ge1xuICAgIGNyZWF0ZVVSTDogbm9vcCxcbiAgICByZWZpbmU6IG5vb3AsXG4gICAgdmFsdWU6IHt9LFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBOZ0Fpc0luc3RhbnRTZWFyY2gpKVxuICAgIHB1YmxpYyBpbnN0YW50U2VhcmNoUGFyZW50OiBhbnlcbiAgKSB7XG4gICAgc3VwZXIoJ1RvZ2dsZVJlZmluZW1lbnQnKTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmNyZWF0ZVdpZGdldChjb25uZWN0VG9nZ2xlLCB7XG4gICAgICBhdHRyaWJ1dGVOYW1lOiB0aGlzLmF0dHJpYnV0ZSxcbiAgICAgIGxhYmVsOiB0aGlzLmxhYmVsLFxuICAgICAgdmFsdWVzOiB0aGlzLnZhbHVlcyxcbiAgICB9KTtcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuICB9XG5cbiAgcHVibGljIGhhbmRsZUNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLnN0YXRlLnJlZmluZSh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgfVxufVxuIl19