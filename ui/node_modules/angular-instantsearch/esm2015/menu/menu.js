/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, Inject, forwardRef } from '@angular/core';
import { connectMenu } from 'instantsearch.js/es/connectors';
import { BaseWidget } from '../base-widget';
import { NgAisInstantSearch } from '../instantsearch/instantsearch';
import { parseNumberInput, noop } from '../utils';
export class NgAisMenu extends BaseWidget {
    /**
     * @param {?} instantSearchParent
     */
    constructor(instantSearchParent) {
        super('Menu');
        this.instantSearchParent = instantSearchParent;
        // render options
        this.showMoreLabel = 'Show more';
        this.showLessLabel = 'Show less';
        this.limit = 10;
        this.state = {
            canRefine: false,
            canToggleShowMore: false,
            createURL: noop,
            isShowingMore: false,
            items: [],
            refine: noop,
            toggleShowMore: noop,
        };
    }
    /**
     * @return {?}
     */
    get isHidden() {
        return this.state.items.length === 0 && this.autoHideContainer;
    }
    /**
     * @return {?}
     */
    get showMoreClass() {
        /** @type {?} */
        let className = this.cx('showMore');
        if (!this.state.canToggleShowMore) {
            className = `${className} ${this.cx('showMore', 'disabled')}`;
        }
        return className;
    }
    /**
     * @return {?}
     */
    get items() {
        return typeof this.transformItems === 'function'
            ? this.transformItems(this.state.items)
            : this.state.items;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.createWidget(connectMenu, {
            limit: parseNumberInput(this.limit),
            showMoreLimit: parseNumberInput(this.showMoreLimit),
            attributeName: this.attribute,
            sortBy: this.sortBy,
        });
        super.ngOnInit();
    }
    /**
     * @param {?} event
     * @param {?} value
     * @return {?}
     */
    handleClick(event, value) {
        event.preventDefault();
        event.stopPropagation();
        this.state.refine(value);
    }
}
NgAisMenu.decorators = [
    { type: Component, args: [{
                selector: 'ais-menu',
                template: `
    <div
      [class]="cx()"
      *ngIf="!isHidden"
    >
      <ul [class]="cx('list')">
        <li
          [class]="getItemClass(item)"
          *ngFor="let item of items"
          (click)="handleClick($event, item.value)"
        >
          <a
            href="{{state.createURL(item.value)}}"
            [class]="cx('link')"
            (click)="handleClick($event, item.value)"
          >
            <span [class]="cx('label')">{{item.label}}</span>
            <span [class]="cx('count')">{{item.count}}</span>
          </a>
        </li>
      </ul>

      <button
        *ngIf="showMoreLimit && state.canToggleShowMore"
        (click)="state.toggleShowMore()"
        [class]="showMoreClass"
      >
        {{state.isShowingMore ? showLessLabel : showMoreLabel}}
      </button>
    </div>
  `,
            },] },
];
/** @nocollapse */
NgAisMenu.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef(() => NgAisInstantSearch),] }] }
];
NgAisMenu.propDecorators = {
    showMoreLabel: [{ type: Input }],
    showLessLabel: [{ type: Input }],
    transformItems: [{ type: Input }],
    attribute: [{ type: Input }],
    limit: [{ type: Input }],
    showMoreLimit: [{ type: Input }],
    sortBy: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NgAisMenu.prototype.showMoreLabel;
    /** @type {?} */
    NgAisMenu.prototype.showLessLabel;
    /** @type {?} */
    NgAisMenu.prototype.transformItems;
    /** @type {?} */
    NgAisMenu.prototype.attribute;
    /** @type {?} */
    NgAisMenu.prototype.limit;
    /** @type {?} */
    NgAisMenu.prototype.showMoreLimit;
    /** @type {?} */
    NgAisMenu.prototype.sortBy;
    /** @type {?} */
    NgAisMenu.prototype.state;
    /** @type {?} */
    NgAisMenu.prototype.instantSearchParent;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVudS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItaW5zdGFudHNlYXJjaC8iLCJzb3VyY2VzIjpbIm1lbnUvbWVudS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVyRSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDN0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsTUFBTSxVQUFVLENBQUM7QUE4Q2xELE1BQU0sT0FBTyxTQUFVLFNBQVEsVUFBVTs7OztJQTBDdkMsWUFFUyxtQkFBd0I7UUFFL0IsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRlAsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFLOztRQTFDakIsa0JBQWEsR0FBVyxXQUFXLENBQUM7UUFDcEMsa0JBQWEsR0FBVyxXQUFXLENBQUM7UUFLcEMsVUFBSyxHQUFxQixFQUFFLENBQUM7UUFJdEMsVUFBSyxHQUFjO1lBQ3hCLFNBQVMsRUFBRSxLQUFLO1lBQ2hCLGlCQUFpQixFQUFFLEtBQUs7WUFDeEIsU0FBUyxFQUFFLElBQUk7WUFDZixhQUFhLEVBQUUsS0FBSztZQUNwQixLQUFLLEVBQUUsRUFBRTtZQUNULE1BQU0sRUFBRSxJQUFJO1lBQ1osY0FBYyxFQUFFLElBQUk7U0FDckIsQ0FBQztJQTJCRixDQUFDOzs7O0lBekJELElBQUksUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUM7SUFDakUsQ0FBQzs7OztJQUVELElBQUksYUFBYTs7WUFDWCxTQUFTLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUM7UUFFbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLEVBQUU7WUFDakMsU0FBUyxHQUFHLEdBQUcsU0FBUyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxFQUFFLENBQUM7U0FDL0Q7UUFFRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDOzs7O0lBRUQsSUFBSSxLQUFLO1FBQ1AsT0FBTyxPQUFPLElBQUksQ0FBQyxjQUFjLEtBQUssVUFBVTtZQUM5QyxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUN2QyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7SUFDdkIsQ0FBQzs7OztJQVNNLFFBQVE7UUFDYixJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRTtZQUM3QixLQUFLLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUNuQyxhQUFhLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQztZQUNuRCxhQUFhLEVBQUUsSUFBSSxDQUFDLFNBQVM7WUFDN0IsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1NBQ3BCLENBQUMsQ0FBQztRQUVILEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuQixDQUFDOzs7Ozs7SUFFRCxXQUFXLENBQUMsS0FBaUIsRUFBRSxLQUFhO1FBQzFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN2QixLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7UUFFeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0IsQ0FBQzs7O1lBbkdGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsVUFBVTtnQkFDcEIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E4QlQ7YUFDRjs7Ozs0Q0E0Q0ksTUFBTSxTQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQzs7OzRCQXpDN0MsS0FBSzs0QkFDTCxLQUFLOzZCQUNMLEtBQUs7d0JBR0wsS0FBSztvQkFDTCxLQUFLOzRCQUNMLEtBQUs7cUJBQ0wsS0FBSzs7OztJQVJOLGtDQUFvRDs7SUFDcEQsa0NBQW9EOztJQUNwRCxtQ0FBMEM7O0lBRzFDLDhCQUFrQzs7SUFDbEMsMEJBQTZDOztJQUM3QyxrQ0FBZ0Q7O0lBQ2hELDJCQUErRDs7SUFFL0QsMEJBUUU7O0lBdUJBLHdDQUMrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIEluamVjdCwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBjb25uZWN0TWVudSB9IGZyb20gJ2luc3RhbnRzZWFyY2guanMvZXMvY29ubmVjdG9ycyc7XG5pbXBvcnQgeyBCYXNlV2lkZ2V0IH0gZnJvbSAnLi4vYmFzZS13aWRnZXQnO1xuaW1wb3J0IHsgTmdBaXNJbnN0YW50U2VhcmNoIH0gZnJvbSAnLi4vaW5zdGFudHNlYXJjaC9pbnN0YW50c2VhcmNoJztcbmltcG9ydCB7IHBhcnNlTnVtYmVySW5wdXQsIG5vb3AgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCB0eXBlIE1lbnVTdGF0ZSA9IHtcbiAgY2FuUmVmaW5lOiBib29sZWFuO1xuICBjYW5Ub2dnbGVTaG93TW9yZTogYm9vbGVhbjtcbiAgY3JlYXRlVVJMOiBGdW5jdGlvbjtcbiAgaXNTaG93aW5nTW9yZTogYm9vbGVhbjtcbiAgaXRlbXM6IHt9W107XG4gIHJlZmluZTogRnVuY3Rpb247XG4gIHRvZ2dsZVNob3dNb3JlOiBGdW5jdGlvbjtcbn07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Fpcy1tZW51JyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2XG4gICAgICBbY2xhc3NdPVwiY3goKVwiXG4gICAgICAqbmdJZj1cIiFpc0hpZGRlblwiXG4gICAgPlxuICAgICAgPHVsIFtjbGFzc109XCJjeCgnbGlzdCcpXCI+XG4gICAgICAgIDxsaVxuICAgICAgICAgIFtjbGFzc109XCJnZXRJdGVtQ2xhc3MoaXRlbSlcIlxuICAgICAgICAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCJcbiAgICAgICAgICAoY2xpY2spPVwiaGFuZGxlQ2xpY2soJGV2ZW50LCBpdGVtLnZhbHVlKVwiXG4gICAgICAgID5cbiAgICAgICAgICA8YVxuICAgICAgICAgICAgaHJlZj1cInt7c3RhdGUuY3JlYXRlVVJMKGl0ZW0udmFsdWUpfX1cIlxuICAgICAgICAgICAgW2NsYXNzXT1cImN4KCdsaW5rJylcIlxuICAgICAgICAgICAgKGNsaWNrKT1cImhhbmRsZUNsaWNrKCRldmVudCwgaXRlbS52YWx1ZSlcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIFtjbGFzc109XCJjeCgnbGFiZWwnKVwiPnt7aXRlbS5sYWJlbH19PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gW2NsYXNzXT1cImN4KCdjb3VudCcpXCI+e3tpdGVtLmNvdW50fX08L3NwYW4+XG4gICAgICAgICAgPC9hPlxuICAgICAgICA8L2xpPlxuICAgICAgPC91bD5cblxuICAgICAgPGJ1dHRvblxuICAgICAgICAqbmdJZj1cInNob3dNb3JlTGltaXQgJiYgc3RhdGUuY2FuVG9nZ2xlU2hvd01vcmVcIlxuICAgICAgICAoY2xpY2spPVwic3RhdGUudG9nZ2xlU2hvd01vcmUoKVwiXG4gICAgICAgIFtjbGFzc109XCJzaG93TW9yZUNsYXNzXCJcbiAgICAgID5cbiAgICAgICAge3tzdGF0ZS5pc1Nob3dpbmdNb3JlID8gc2hvd0xlc3NMYWJlbCA6IHNob3dNb3JlTGFiZWx9fVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIGAsXG59KVxuZXhwb3J0IGNsYXNzIE5nQWlzTWVudSBleHRlbmRzIEJhc2VXaWRnZXQge1xuICAvLyByZW5kZXIgb3B0aW9uc1xuICBASW5wdXQoKSBwdWJsaWMgc2hvd01vcmVMYWJlbDogc3RyaW5nID0gJ1Nob3cgbW9yZSc7XG4gIEBJbnB1dCgpIHB1YmxpYyBzaG93TGVzc0xhYmVsOiBzdHJpbmcgPSAnU2hvdyBsZXNzJztcbiAgQElucHV0KCkgcHVibGljIHRyYW5zZm9ybUl0ZW1zPzogRnVuY3Rpb247XG5cbiAgLy8gY29ubmVjdG9yIG9wdGlvbnNcbiAgQElucHV0KCkgcHVibGljIGF0dHJpYnV0ZTogc3RyaW5nO1xuICBASW5wdXQoKSBwdWJsaWMgbGltaXQ/OiBudW1iZXIgfCBzdHJpbmcgPSAxMDtcbiAgQElucHV0KCkgcHVibGljIHNob3dNb3JlTGltaXQ/OiBudW1iZXIgfCBzdHJpbmc7XG4gIEBJbnB1dCgpIHB1YmxpYyBzb3J0Qnk/OiBzdHJpbmdbXSB8ICgoaXRlbTogb2JqZWN0KSA9PiBudW1iZXIpO1xuXG4gIHB1YmxpYyBzdGF0ZTogTWVudVN0YXRlID0ge1xuICAgIGNhblJlZmluZTogZmFsc2UsXG4gICAgY2FuVG9nZ2xlU2hvd01vcmU6IGZhbHNlLFxuICAgIGNyZWF0ZVVSTDogbm9vcCxcbiAgICBpc1Nob3dpbmdNb3JlOiBmYWxzZSxcbiAgICBpdGVtczogW10sXG4gICAgcmVmaW5lOiBub29wLFxuICAgIHRvZ2dsZVNob3dNb3JlOiBub29wLFxuICB9O1xuXG4gIGdldCBpc0hpZGRlbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pdGVtcy5sZW5ndGggPT09IDAgJiYgdGhpcy5hdXRvSGlkZUNvbnRhaW5lcjtcbiAgfVxuXG4gIGdldCBzaG93TW9yZUNsYXNzKCkge1xuICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmN4KCdzaG93TW9yZScpO1xuXG4gICAgaWYgKCF0aGlzLnN0YXRlLmNhblRvZ2dsZVNob3dNb3JlKSB7XG4gICAgICBjbGFzc05hbWUgPSBgJHtjbGFzc05hbWV9ICR7dGhpcy5jeCgnc2hvd01vcmUnLCAnZGlzYWJsZWQnKX1gO1xuICAgIH1cblxuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cblxuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnRyYW5zZm9ybUl0ZW1zID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHRoaXMudHJhbnNmb3JtSXRlbXModGhpcy5zdGF0ZS5pdGVtcylcbiAgICAgIDogdGhpcy5zdGF0ZS5pdGVtcztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBOZ0Fpc0luc3RhbnRTZWFyY2gpKVxuICAgIHB1YmxpYyBpbnN0YW50U2VhcmNoUGFyZW50OiBhbnlcbiAgKSB7XG4gICAgc3VwZXIoJ01lbnUnKTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmNyZWF0ZVdpZGdldChjb25uZWN0TWVudSwge1xuICAgICAgbGltaXQ6IHBhcnNlTnVtYmVySW5wdXQodGhpcy5saW1pdCksXG4gICAgICBzaG93TW9yZUxpbWl0OiBwYXJzZU51bWJlcklucHV0KHRoaXMuc2hvd01vcmVMaW1pdCksXG4gICAgICBhdHRyaWJ1dGVOYW1lOiB0aGlzLmF0dHJpYnV0ZSxcbiAgICAgIHNvcnRCeTogdGhpcy5zb3J0QnksXG4gICAgfSk7XG5cbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuICB9XG5cbiAgaGFuZGxlQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdGhpcy5zdGF0ZS5yZWZpbmUodmFsdWUpO1xuICB9XG59XG4iXX0=